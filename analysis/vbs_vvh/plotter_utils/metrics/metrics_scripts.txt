# plotter_utils/metrics/base.py

import numpy as np
from abc import ABC, abstractmethod

import logging
log = logging.getLogger(__name__)


class MetricResult:
    """
    Container passed from metrics -> plotting.
    """
    def __init__(self, x, y, yerr=None, label=None):
        self.x = x
        self.y = y
        self.yerr = yerr
        self.label = label


class MetricBase(ABC):
    name = None
    requires = ()   # ("sig", "bkg", "data")
    y_range = None   # (ymin, ymax)

    def __init__(self, *, sig=None, bkg=None, data=None):
        self.sig = sig
        self.bkg = bkg
        self.data = data

    def available(self):
        missing = [k for k in self.requires if getattr(self, k) is None]
        return len(missing) == 0, missing

    @staticmethod
    def safe_divide(num, den):
        return np.divide(
            num, den,
            out=np.full_like(num, np.nan, dtype=float),
            where=den > 0
        )

    @abstractmethod
    def compute(self):
        """
        Return MetricResult
        """
        pass
    
    @staticmethod
    def to_1d(arr):
        """
        Collapse all non-dense axes.
        Expects dense axis to be the last one.
        """
        arr = np.asarray(arr)

        # Sum over all axes except the last (dense) one
        if arr.ndim > 1:
            axes = tuple(range(arr.ndim - 1))
            arr = arr.sum(axis=axes)

        return arr

# plotter_utils/metrics/dataMC.py

import numpy as np
from .base import MetricBase, MetricResult

import logging
log = logging.getLogger(__name__)

class DataMCMetric(MetricBase):
    name = "dataMC"
    requires = ("data", "bkg")
    y_range = (0.3, 3)

    def compute(self):
        data_vals = self.to_1d(self.data.values(flow=False))
        bkg_vals = self.to_1d(self.bkg.values_total(flow=False))

        ratio = self.safe_divide(data_vals, bkg_vals)

        x = self.data.hist.axes[-1].centers

        return MetricResult(
            x=x,
            y=ratio,
            label="Data / MC"
        )


# plotter_utils/metrics/significance.py

import numpy as np
from .base import MetricBase, MetricResult

import logging
log = logging.getLogger(__name__)

class SignificanceMetric(MetricBase):
    name = "significance"
    requires = ("sig", "bkg")
    y_range = (0, 0.1)

    def compute(self):
        sig_vals = self.to_1d(self.sig.values(flow=False))
        bkg_vals = self.to_1d(self.bkg.values_total(flow=False))

        log.debug(f"sig shape {sig_vals.shape}")
        log.debug(f"bkg shape {bkg_vals.shape}")
        log.debug(f"sig_vals {sig_vals[:10]}")
        log.debug(f"bkg_vals {bkg_vals[:10]}")

        y = self.safe_divide(sig_vals, np.sqrt(bkg_vals))
        log.debug(f"signif(y) shape {y.shape}")

        x = self.sig.hist.axes[-1].centers
        log.debug(f"bin(x) shape {x.shape}")

        log.debug(f"y {y[:10]}")
        log.debug(f"x {x[:10]}")

        return MetricResult(
            x=x,
            y=y,
            label=r"$S/\sqrt{B}$"
        )
