# plotter_utils/plotting/draw.py

import matplotlib.pyplot as plt
from plotter_utils.metrics.significance import SignificanceMetric
from plotter_utils.metrics.dataMC import DataMCMetric
from .main_plot import draw_main_plot
from .subplots import draw_metric_subplot



METRIC_REGISTRY = {
    "significance": SignificanceMetric,
    "dataMC": DataMCMetric,
}


def draw(
    *,
    sig=None,
    bkg=None,
    data=None,
    proc_map=None,
    config=None,
    title=None,
):
    subplots = config["SUBPLOTS"]
    ratios = config["FIG_RATIO"]

    heights = [ratios["main"]] + [ratios[s] for s in subplots]
    nrows = 1 + len(subplots)

    fig, axes = plt.subplots(
        nrows=nrows,
        ncols=1,
        figsize=(7, 3 + 2 * nrows),
        gridspec_kw={"height_ratios": heights},
        sharex=True,
    )

    ax_main = axes[0]
    draw_main_plot(ax_main, sig=sig, bkg=bkg, data=data, proc_map=proc_map)
    ax_main.set_title(title)

    for ax, name in zip(axes[1:], subplots):
        metric_cls = METRIC_REGISTRY[name]
        metric = metric_cls(sig=sig, bkg=bkg, data=data)
        draw_metric_subplot(ax, metric, name)

    return fig


# plotter_utils/plotting/main_plot.py 
# main_plot is the main panel in the plot that shows the kinematic distribution, not the "main" script

import logging
log = logging.getLogger(__name__)

def order_backgrounds(bkg, mode="yield"):
    """
    Get bkg proc type order by yield.
    """
    if mode == "yield":
        yields = {
            p: bkg.hist[{"process_grp": [p]}].values(flow=True).sum()
            for p in bkg.hist.axes["process_grp"]
        }
        logging.debug(f"in main_plot.order_bkg: {yields}")
        return sorted(yields, key=yields.get, reverse=False)
    
def get_scaled_signal(sig, bkg, mode="match_bkg"):
    """
    Scale signal to bkg 
    """
    if mode == "match_bkg":
        s = sig.total_yield()
        b = bkg.total_yield()
        if s > 0:
            factor = b / s
            return sig.hist * factor, factor
    return sig.hist, 1.0

def draw_main_plot(ax, *, sig=None, bkg=None, data=None, proc_map=None):
    """
    Draw the main kinematic distribution.
    """

    if bkg is not None:
        order = order_backgrounds(bkg)
        colors = [
            proc_map.background_colors[p]
            for p in order
        ]
        logging.debug(f"in draw_main_plot: order: {order}")
        logging.debug(f"in draw_main_plot: colors: {colors}")
        logging.debug(f"in draw_main_plot lebel is {list(bkg.hist.axes['process_grp'])}")
        bkg.hist[{"process_grp": order}].plot1d(
            ax=ax,
            stack=True,
            histtype="fill",
            color=colors,
            label=list(bkg.hist.axes["process_grp"]),
        )
    else:
        log.warning("Background histogram missing")

    if sig is not None:
        sig_plot, scale = get_scaled_signal(sig, bkg)
        sig_plot.plot1d(
            ax=ax,
            color="red",
            linewidth=2,
            label=f"Signal Ã— {scale:.1f}",
        )
    logging.debug(f"in draw main plot data is {data.hist}")
    if data is not None:
        data.hist.plot1d(
            ax=ax,
            color="blue",
            linewidth=2,
            label="Data",
        )

    ax.legend()

# plotter_utils/plotting/subplots.py

import logging

log = logging.getLogger(__name__)


def draw_metric_subplot(ax, metric, metric_name):
    ok, missing = metric.available()
    if metric.y_range:
        ax.set_ylim(*metric.y_range)

    logging.debug(f"in draw_metric_subplot we have\n {metric_name}: {metric.compute().x}\n{metric.compute().y}")

    if not ok:
        msg = f"{metric_name}: {missing} not available"
        log.warning(msg)
        ax.text(
            0.5, 0.5, msg,
            ha="center", va="center",
            transform=ax.transAxes,
        )
        ax.set_axis_off()
        return

    result = metric.compute()

    if result.yerr is not None:
        ax.errorbar(
            result.x,
            result.y,
            yerr=result.yerr,
            fmt="o",
        )
    else:
        ax.step(result.x, result.y, where="mid")

    ax.axhline(1.0 if metric_name == "dataMC" else 0.0,
               color="gray", linestyle="--")

    ax.set_ylabel(result.label)
